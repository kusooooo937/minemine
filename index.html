<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Web Minecraft - Final Physics Fix</title>
    <style>
        body { margin: 0; overflow: hidden; touch-action: none; background-color: #87CEEB; font-family: sans-serif; user-select: none; }
        canvas { display: block; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        /* スティック */
        #joystick-container { position: absolute; bottom: 40px; left: 40px; width: 120px; height: 120px; background: rgba(255, 255, 255, 0.2); border-radius: 50%; pointer-events: auto; border: 2px solid rgba(255, 255, 255, 0.5); }
        #joystick-knob { position: absolute; top: 35px; left: 35px; width: 50px; height: 50px; background: rgba(255, 255, 255, 0.8); border-radius: 50%; pointer-events: none; }
        /* ボタン */
        #action-grid { position: absolute; bottom: 40px; right: 40px; display: grid; grid-template-areas: "up up" "left right" "down down"; gap: 15px; pointer-events: auto; }
        .act-btn { width: 75px; height: 75px; border-radius: 50%; background: rgba(0, 0, 0, 0.4); color: white; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 2px solid #fff; pointer-events: auto; }
        .act-btn:active { background: rgba(255, 255, 255, 0.6); transform: scale(0.9); }
        #btn-build { background: rgba(0, 150, 0, 0.6); grid-area: left; }
        #btn-break { background: rgba(150, 0, 0, 0.6); grid-area: right; }
        #btn-jump { background: rgba(200, 150, 0, 0.6); grid-area: up; }
        #btn-fly-down { background: rgba(50, 50, 50, 0.6); grid-area: down; }
        #top-bar { position: absolute; top: 10px; width: 100%; display: flex; justify-content: center; gap: 10px; pointer-events: auto; }
        .toggle-btn { padding: 10px 15px; background: rgba(0,0,0,0.6); color: white; border-radius: 20px; border: none; }
        #crosshair { position: absolute; top: 50%; left: 50%; width: 12px; height: 12px; border: 2px solid #fff; border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none; }
    </style>
</head>
<body>
    <div id="crosshair"></div>
    <div id="ui-layer">
        <div id="top-bar">
            <button class="toggle-btn" id="mode-physics-btn">サバイバル</button>
            <button class="toggle-btn" id="block-type-btn">土ブロック</button>
        </div>
        <div id="joystick-container"><div id="joystick-knob"></div></div>
        <div id="action-grid">
            <div class="act-btn" id="btn-jump">JUMP</div>
            <div class="act-btn" id="btn-build">おく</div>
            <div class="act-btn" id="btn-break">こわす</div>
            <div class="act-btn" id="btn-fly-down" style="display:none;">下降</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
    window.onload = function() {
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 15, 60);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 0.8));
        camera.position.set(0, 10, 0);

        const worldData = new Map();
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const materials = [
            new THREE.MeshLambertMaterial({ color: 0x4CAF50 }),
            new THREE.MeshLambertMaterial({ color: 0x795548 }),
            new THREE.MeshLambertMaterial({ color: 0x808080 })
        ];

        function addBlock(x, y, z, mIdx) {
            const key = `${Math.floor(x)},${Math.floor(y)},${Math.floor(z)}`;
            if (worldData.has(key)) return;
            const mesh = new THREE.Mesh(geometry, materials[mIdx % 3]);
            mesh.position.set(Math.floor(x) + 0.5, Math.floor(y) + 0.5, Math.floor(z) + 0.5);
            scene.add(mesh);
            worldData.set(key, mesh);
        }

        // 地面生成
        for (let x = -15; x < 15; x++) {
            for (let z = -15; z < 15; z++) {
                addBlock(x, -1, z, (Math.abs(x+z)%2));
            }
        }

        const player = { 
            radius: 0.3, 
            eyeHeight: 1.6, 
            vel: new THREE.Vector3(), 
            onGround: false, 
            fly: false, 
            speed: 5.0,
            gravity: 24.0
        };
        let moveState = { x: 0, y: 0 };
        let matIdx = 0;

        // 指定座標にブロックがあるか
        function isBlockAt(x, y, z) {
            return worldData.has(`${Math.floor(x)},${Math.floor(y)},${Math.floor(z)}`);
        }

        // AABB(衝突判定ボックス)チェック
        function checkCollision(pos) {
            const r = player.radius;
            const h = player.eyeHeight;
            // プレイヤーの体の範囲にあるブロック座標をすべてチェック
            for(let ix = Math.floor(pos.x - r); ix <= Math.floor(pos.x + r); ix++) {
                for(let iy = Math.floor(pos.y - h + 0.05); iy <= Math.floor(pos.y + 0.3); iy++) {
                    for(let iz = Math.floor(pos.z - r); iz <= Math.floor(pos.z + r); iz++) {
                        if (worldData.has(`${ix},${iy},${iz}`)) return true;
                    }
                }
            }
            return false;
        }

        // ジョイスティック
        const jContainer = document.getElementById('joystick-container');
        const jKnob = document.getElementById('joystick-knob');
        let jActive = false;
        function handleJoystick(e) {
            if (!jActive) return;
            const touch = e.touches ? e.touches[0] : e;
            const rect = jContainer.getBoundingClientRect();
            const dx = touch.clientX - (rect.left + rect.width / 2);
            const dy = touch.clientY - (rect.top + rect.height / 2);
            const dist = Math.min(Math.sqrt(dx*dx + dy*dy), 40);
            const angle = Math.atan2(dy, dx);
            jKnob.style.transform = `translate(${Math.cos(angle)*dist}px, ${Math.sin(angle)*dist}px)`;
            moveState.x = (Math.cos(angle)*dist) / 40; moveState.y = (Math.sin(angle)*dist) / 40;
        }
        jContainer.addEventListener('touchstart', (e) => { jActive = true; handleJoystick(e); });
        window.addEventListener('touchmove', (e) => { if(jActive) { e.preventDefault(); handleJoystick(e); } }, { passive: false });
        window.addEventListener('touchend', () => { jActive = false; jKnob.style.transform = `translate(0,0)`; moveState = { x: 0, y: 0 }; });

        // アクションボタン
        const ray = new THREE.Raycaster();
        function performAction(isBuild) {
            ray.setFromCamera(new THREE.Vector2(), camera); ray.far = 6;
            const hits = ray.intersectObjects(Array.from(worldData.values()));
            if (hits.length > 0) {
                const h = hits[0], p = h.point, n = h.face.normal;
                const bx = Math.floor(p.x - n.x*0.01), by = Math.floor(p.y - n.y*0.01), bz = Math.floor(p.z - n.z*0.01);
                if (isBuild) addBlock(bx + Math.round(n.x), by + Math.round(n.y), bz + Math.round(n.z), matIdx);
                else { const key = `${bx},${by},${bz}`; const mesh = worldData.get(key); if(mesh){scene.remove(mesh); worldData.delete(key);} }
            }
        }
        document.getElementById('btn-build').addEventListener('touchstart', (e) => { e.preventDefault(); performAction(true); });
        document.getElementById('btn-break').addEventListener('touchstart', (e) => { e.preventDefault(); performAction(false); });
        document.getElementById('btn-jump').addEventListener('touchstart', (e) => {
            e.preventDefault(); if (player.fly) player.vel.y = 8; else if (player.onGround) { player.vel.y = 8.5; player.onGround = false; }
        });
        document.getElementById('btn-fly-down').addEventListener('touchstart', (e) => { e.preventDefault(); if(player.fly) player.vel.y = -8; });

        document.getElementById('mode-physics-btn').onclick = function() {
            player.fly = !player.fly;
            this.innerText = player.fly ? "クリエイティブ" : "サバイバル";
            document.getElementById('btn-fly-down').style.display = player.fly ? 'flex' : 'none';
            document.getElementById('btn-jump').innerText = player.fly ? '上昇' : 'JUMP';
        };
        document.getElementById('block-type-btn').onclick = function() {
            matIdx = (matIdx + 1) % 3;
            this.innerText = ["草ブロック", "土ブロック", "石ブロック"][matIdx];
        };

        // 視点移動
        let yaw = 0, pitch = 0, lastX, lastY;
        window.addEventListener('touchstart', (e) => {
            if (e.target.closest('#joystick-container') || e.target.closest('.act-btn') || e.target.closest('.toggle-btn')) return;
            lastX = e.touches[0].clientX; lastY = e.touches[0].clientY;
        });
        window.addEventListener('touchmove', (e) => {
            if (jActive || e.touches.length > 1 || e.target.closest('.act-btn')) return;
            const dx = e.touches[0].clientX - lastX; const dy = e.touches[0].clientY - lastY;
            yaw -= dx * 0.005; pitch -= dy * 0.005;
            pitch = Math.max(-1.5, Math.min(1.5, pitch));
            camera.rotation.set(pitch, yaw, 0, 'YXZ');
            lastX = e.touches[0].clientX; lastY = e.touches[0].clientY;
        });

        const clock = new THREE.Clock();
        function loop() {
            requestAnimationFrame(loop);
            const dt = Math.min(clock.getDelta(), 0.1);
            
            const fw = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion); fw.y = 0; fw.normalize();
            const rt = new THREE.Vector3(1,0,0).applyQuaternion(camera.quaternion); rt.y = 0; rt.normalize();
            
            if (player.fly) {
                camera.position.addScaledVector(fw, -moveState.y * 10 * dt);
                camera.position.addScaledVector(rt, moveState.x * 10 * dt);
                camera.position.y += player.vel.y * dt;
                player.vel.y *= 0.85;
            } else {
                // 1. 重力の適用
                player.vel.y -= player.gravity * dt;
                
                // 2. 軸別に移動を試行（これがバウンド対策のキモ）
                const moveX = (fw.x * -moveState.y + rt.x * moveState.x) * player.speed * dt;
                const moveZ = (fw.z * -moveState.y + rt.z * moveState.x) * player.speed * dt;
                const moveY = player.vel.y * dt;

                // X軸移動
                camera.position.x += moveX;
                if(checkCollision(camera.position)) camera.position.x -= moveX;

                // Z軸移動
                camera.position.z += moveZ;
                if(checkCollision(camera.position)) camera.position.z -= moveZ;

                // Y軸移動
                camera.position.y += moveY;
                if(checkCollision(camera.position)) {
                    if(player.vel.y < 0) { // 着地
                        player.onGround = true;
                        // 座標の端数を切り捨てて、地面の「真上」に強制テレポート
                        camera.position.y = Math.floor(camera.position.y - player.eyeHeight + 0.5) + player.eyeHeight;
                    }
                    player.vel.y = 0;
                } else {
                    player.onGround = false;
                }
                
                // 画面外（落下）対策
                if(camera.position.y < -30) camera.position.set(0, 10, 0);
            }
            renderer.render(scene, camera);
        }
        loop();
    };
    </script>
</body>
</html>
