<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Web Minecraft - Full Collision Edition</title>
    <style>
        body { margin: 0; overflow: hidden; touch-action: none; background-color: #87CEEB; font-family: sans-serif; user-select: none; }
        canvas { display: block; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        #joystick-container { position: absolute; bottom: 40px; left: 40px; width: 120px; height: 120px; background: rgba(255, 255, 255, 0.2); border-radius: 50%; pointer-events: auto; border: 2px solid rgba(255, 255, 255, 0.5); }
        #joystick-knob { position: absolute; top: 35px; left: 35px; width: 50px; height: 50px; background: rgba(255, 255, 255, 0.8); border-radius: 50%; pointer-events: none; }
        #action-grid { position: absolute; bottom: 40px; right: 40px; display: grid; grid-template-areas: "up up" "left right" "down down"; gap: 15px; pointer-events: auto; }
        .act-btn { width: 75px; height: 75px; border-radius: 50%; background: rgba(0, 0, 0, 0.4); color: white; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 2px solid #fff; pointer-events: auto; }
        .act-btn:active { background: rgba(255, 255, 255, 0.6); transform: scale(0.9); }
        #btn-build { background: rgba(0, 150, 0, 0.6); grid-area: left; }
        #btn-break { background: rgba(150, 0, 0, 0.6); grid-area: right; }
        #btn-jump { background: rgba(200, 150, 0, 0.6); grid-area: up; }
        #btn-fly-down { background: rgba(50, 50, 50, 0.6); grid-area: down; }
        #top-bar { position: absolute; top: 10px; width: 100%; display: flex; justify-content: center; gap: 10px; pointer-events: auto; }
        .toggle-btn { padding: 10px 15px; background: rgba(0,0,0,0.6); color: white; border-radius: 20px; border: none; }
        #crosshair { position: absolute; top: 50%; left: 50%; width: 12px; height: 12px; border: 2px solid #fff; border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none; }
    </style>
</head>
<body>
    <div id="crosshair"></div>
    <div id="ui-layer">
        <div id="top-bar">
            <button class="toggle-btn" id="mode-physics-btn">サバイバル</button>
            <button class="toggle-btn" id="block-type-btn">土ブロック</button>
        </div>
        <div id="joystick-container"><div id="joystick-knob"></div></div>
        <div id="action-grid">
            <div class="act-btn" id="btn-jump">JUMP</div>
            <div class="act-btn" id="btn-build">おく</div>
            <div class="act-btn" id="btn-break">こわす</div>
            <div class="act-btn" id="btn-fly-down" style="display:none;">下降</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
    window.onload = function() {
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 15, 50);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 0.8));
        camera.position.set(0, 5, 5);

        const worldData = new Map();
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const materials = [
            new THREE.MeshLambertMaterial({ color: 0x4CAF50 }),
            new THREE.MeshLambertMaterial({ color: 0x795548 }),
            new THREE.MeshLambertMaterial({ color: 0x808080 })
        ];

        function addBlock(x, y, z, mIdx) {
            const key = `${x},${y},${z}`;
            if (worldData.has(key)) return;
            const mesh = new THREE.Mesh(geometry, materials[mIdx % 3]);
            mesh.position.set(x + 0.5, y + 0.5, z + 0.5);
            scene.add(mesh);
            worldData.set(key, mesh);
        }

        // 地面生成
        for (let x = -15; x < 15; x++) {
            for (let z = -15; z < 15; z++) {
                addBlock(x, -1, z, (Math.abs(x+z)%2));
            }
        }

        const player = { 
            radius: 0.3, 
            height: 1.7, 
            eyeHeight: 1.5,
            vel: new THREE.Vector3(), 
            onGround: false, 
            fly: false, 
            speed: 5.5 
        };
        let moveState = { x: 0, y: 0 };
        let matIdx = 0;

        // --- 全方向当たり判定関数 ---
        function checkCollision(pos) {
            // プレイヤーの体の範囲（足元から頭まで）を網羅する複数の点でチェック
            const checkPoints = [
                { x: pos.x - player.radius, y: pos.y - player.eyeHeight + 0.1, z: pos.z - player.radius },
                { x: pos.x + player.radius, y: pos.y - player.eyeHeight + 0.1, z: pos.z - player.radius },
                { x: pos.x - player.radius, y: pos.y - player.eyeHeight + 0.1, z: pos.z + player.radius },
                { x: pos.x + player.radius, y: pos.y - player.eyeHeight + 0.1, z: pos.z + player.radius },
                { x: pos.x, y: pos.y - player.eyeHeight + 0.1, z: pos.z }, // 足元中心
                { x: pos.x, y: pos.y - 0.1, z: pos.z }, // 腰
                { x: pos.x, y: pos.y + 0.2, z: pos.z }  // 頭上
            ];

            for (let pt of checkPoints) {
                const k = `${Math.floor(pt.x)},${Math.floor(pt.y)},${Math.floor(pt.z)}`;
                if (worldData.has(k)) return true;
            }
            return false;
        }

        // ジョイスティック設定
        const jContainer = document.getElementById('joystick-container');
        const jKnob = document.getElementById('joystick-knob');
        let jActive = false;

        function handleJoystick(e) {
            if (!jActive) return;
            const touch = e.touches ? e.touches[0] : e;
            const rect = jContainer.getBoundingClientRect();
            const dx = touch.clientX - (rect.left + rect.width / 2);
            const dy = touch.clientY - (rect.top + rect.height / 2);
            const dist = Math.min(Math.sqrt(dx*dx + dy*dy), 40);
            const angle = Math.atan2(dy, dx);
            const tx = Math.cos(angle) * dist;
            const ty = Math.sin(angle) * dist;
            jKnob.style.transform = `translate(${tx}px, ${ty}px)`;
            moveState.x = tx / 40; moveState.y = ty / 40;
        }

        jContainer.addEventListener('touchstart', (e) => { jActive = true; handleJoystick(e); });
        window.addEventListener('touchmove', (e) => { if(jActive) { e.preventDefault(); handleJoystick(e); } }, { passive: false });
        window.addEventListener('touchend', () => { jActive = false; jKnob.style.transform = `translate(0,0)`; moveState = { x: 0, y: 0 }; });

        // ボタンアクション
        const ray = new THREE.Raycaster();
        function performAction(isBuild) {
            ray.setFromCamera(new THREE.Vector2(), camera); ray.far = 6;
            const hits = ray.intersectObjects(Array.from(worldData.values()));
            if (hits.length > 0) {
                const h = hits[0], p = h.point, n = h.face.normal;
                const bx = Math.floor(p.x - n.x*0.1), by = Math.floor(p.y - n.y*0.1), bz = Math.floor(p.z - n.z*0.1);
                if (isBuild) addBlock(bx + Math.round(n.x), by + Math.round(n.y), bz + Math.round(n.z), matIdx);
                else { const key = `${bx},${by},${bz}`; scene.remove(worldData.get(key)); worldData.delete(key); }
            }
        }

        document.getElementById('btn-build').addEventListener('touchstart', (e) => { e.preventDefault(); performAction(true); });
        document.getElementById('btn-break').addEventListener('touchstart', (e) => { e.preventDefault(); performAction(false); });
        document.getElementById('btn-jump').addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (player.fly) player.vel.y = player.speed;
            else if (player.onGround) player.vel.y = 10;
        });
        document.getElementById('btn-fly-down').addEventListener('touchstart', (e) => { e.preventDefault(); if(player.fly) player.vel.y = -player.speed; });

        document.getElementById('mode-physics-btn').onclick = function() {
            player.fly = !player.fly;
            this.innerText = player.fly ? "クリエイティブ" : "サバイバル";
            document.getElementById('btn-fly-down').style.display = player.fly ? 'flex' : 'none';
            document.getElementById('btn-jump').innerText = player.fly ? '上昇' : 'JUMP';
        };

        document.getElementById('block-type-btn').onclick = function() {
            matIdx = (matIdx + 1) % 3;
            this.innerText = ["草ブロック", "土ブロック", "石ブロック"][matIdx];
        };

        let yaw = 0, pitch = 0, lastX, lastY;
        window.addEventListener('touchstart', (e) => {
            if (e.target.closest('#joystick-container') || e.target.closest('.act-btn') || e.target.closest('.toggle-btn')) return;
            lastX = e.touches[0].clientX; lastY = e.touches[0].clientY;
        });
        window.addEventListener('touchmove', (e) => {
            if (jActive || e.touches.length > 1 || e.target.closest('.act-btn')) return;
            const dx = e.touches[0].clientX - lastX;
            const dy = e.touches[0].clientY - lastY;
            yaw -= dx * 0.005; pitch -= dy * 0.005;
            pitch = Math.max(-1.5, Math.min(1.5, pitch));
            camera.rotation.set(pitch, yaw, 0, 'YXZ');
            lastX = e.touches[0].clientX; lastY = e.touches[0].clientY;
        });

        const clock = new THREE.Clock();
        function loop() {
            requestAnimationFrame(loop);
            const dt = Math.min(clock.getDelta(), 0.1);
            const fw = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion); fw.y = 0; fw.normalize();
            const rt = new THREE.Vector3(1,0,0).applyQuaternion(camera.quaternion); rt.y = 0; rt.normalize();
            
            // --- 物理更新 (全方向判定) ---
            if (player.fly) {
                camera.position.addScaledVector(fw, -moveState.y * player.speed * dt);
                camera.position.addScaledVector(rt, moveState.x * player.speed * dt);
                camera.position.y += player.vel.y * dt;
                player.vel.y *= 0.9;
            } else {
                // X方向移動チェック
                let nextX = camera.position.clone().addScaledVector(fw, -moveState.y * player.speed * dt);
                nextX.addScaledVector(rt, moveState.x * player.speed * dt);
                if (!checkCollision({x: nextX.x, y: camera.position.y, z: nextX.z})) {
                    camera.position.x = nextX.x;
                    camera.position.z = nextX.z;
                }

                // Y方向（垂直）移動チェック
                player.vel.y -= 28 * dt;
                let nextY = camera.position.y + player.vel.y * dt;
                if (checkCollision({x: camera.position.x, y: nextY, z: camera.position.z})) {
                    if (player.vel.y < 0) { // 着地
                        player.onGround = true;
                        camera.position.y = Math.floor(nextY - player.eyeHeight) + player.eyeHeight + 1.0;
                    }
                    player.vel.y = 0;
                } else {
                    camera.position.y = nextY;
                    player.onGround = false;
                }
            }
            renderer.render(scene, camera);
        }
        loop();
    };
    </script>
</body>
</html>
