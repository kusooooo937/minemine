<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Web Minecraft - No Interference Physics</title>
    <style>
        body { margin: 0; overflow: hidden; touch-action: none; background-color: #87CEEB; font-family: sans-serif; user-select: none; }
        canvas { display: block; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        #joystick-container { position: absolute; bottom: 40px; left: 40px; width: 120px; height: 120px; background: rgba(255, 255, 255, 0.2); border-radius: 50%; pointer-events: auto; border: 2px solid rgba(255, 255, 255, 0.5); }
        #joystick-knob { position: absolute; top: 35px; left: 35px; width: 50px; height: 50px; background: rgba(255, 255, 255, 0.8); border-radius: 50%; pointer-events: none; }
        #action-grid { position: absolute; bottom: 40px; right: 40px; display: grid; grid-template-areas: "up up" "left right" "down down"; gap: 15px; pointer-events: auto; }
        .act-btn { width: 75px; height: 75px; border-radius: 50%; background: rgba(0, 0, 0, 0.4); color: white; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 2px solid #fff; pointer-events: auto; }
        .act-btn:active { background: rgba(255, 255, 255, 0.6); transform: scale(0.9); }
        #btn-build { background: rgba(0, 150, 0, 0.6); grid-area: left; }
        #btn-break { background: rgba(150, 0, 0, 0.6); grid-area: right; }
        #btn-jump { background: rgba(200, 150, 0, 0.6); grid-area: up; }
        #btn-fly-down { background: rgba(50, 50, 50, 0.6); grid-area: down; }
        #top-bar { position: absolute; top: 10px; width: 100%; display: flex; justify-content: center; gap: 10px; pointer-events: auto; }
        .toggle-btn { padding: 10px 15px; background: rgba(0,0,0,0.6); color: white; border-radius: 20px; border: none; }
        #crosshair { position: absolute; top: 50%; left: 50%; width: 12px; height: 12px; border: 2px solid #fff; border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none; }
    </style>
</head>
<body>
    <div id="crosshair"></div>
    <div id="ui-layer">
        <div id="top-bar">
            <button class="toggle-btn" id="mode-physics-btn">サバイバル</button>
            <button class="toggle-btn" id="block-type-btn">土ブロック</button>
        </div>
        <div id="joystick-container"><div id="joystick-knob"></div></div>
        <div id="action-grid">
            <div class="act-btn" id="btn-jump">JUMP</div>
            <div class="act-btn" id="btn-build">おく</div>
            <div class="act-btn" id="btn-break">こわす</div>
            <div class="act-btn" id="btn-fly-down" style="display:none;">下降</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
    window.onload = function() {
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 20, 60);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 0.8));
        camera.position.set(0, 5, 0);

        const worldData = new Map();
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const materials = [
            new THREE.MeshLambertMaterial({ color: 0x4CAF50 }),
            new THREE.MeshLambertMaterial({ color: 0x795548 }),
            new THREE.MeshLambertMaterial({ color: 0x808080 })
        ];

        function addBlock(x, y, z, mIdx) {
            const key = `${Math.floor(x)},${Math.floor(y)},${Math.floor(z)}`;
            if (worldData.has(key)) return;
            const mesh = new THREE.Mesh(geometry, materials[mIdx % 3]);
            mesh.position.set(Math.floor(x) + 0.5, Math.floor(y) + 0.5, Math.floor(z) + 0.5);
            scene.add(mesh);
            worldData.set(key, mesh);
        }

        // 地面
        for (let x = -15; x < 15; x++) {
            for (let z = -15; z < 15; z++) addBlock(x, -1, z, (Math.abs(x+z)%2));
        }

        const player = { 
            radius: 0.3, 
            eyeHeight: 1.6, 
            vel: new THREE.Vector3(), 
            onGround: false, 
            fly: false, 
            speed: 5.0,
            gravity: 22.0
        };
        let moveState = { x: 0, y: 0 };
        let matIdx = 0;

        // 判定関数：衝突しているか？
        function isColliding(x, y, z) {
            const r = player.radius;
            const h = player.eyeHeight;
            // プレイヤーの四隅と中心（高さ3段階）をチェック
            const testPoints = [
                {x: x-r, y: y-h+0.1, z: z-r}, {x: x+r, y: y-h+0.1, z: z-r},
                {x: x-r, y: y-h+0.1, z: z+r}, {x: x+r, y: y-h+0.1, z: z+r},
                {x: x, y: y-h+0.1, z: z}, // 足元
                {x: x, y: y-0.5, z: z},    // 腰
                {x: x, y: y+0.1, z: z}     // 頭
            ];
            for (let p of testPoints) {
                if (worldData.has(`${Math.floor(p.x)},${Math.floor(p.y)},${Math.floor(p.z)}`)) return true;
            }
            return false;
        }

        // ジョイスティック
        const jContainer = document.getElementById('joystick-container');
        const jKnob = document.getElementById('joystick-knob');
        let jActive = false;
        function handleJoystick(e) {
            if (!jActive) return;
            const touch = e.touches ? e.touches[0] : e;
            const rect = jContainer.getBoundingClientRect();
            const dx = touch.clientX - (rect.left + rect.width/2), dy = touch.clientY - (rect.top + rect.height/2);
            const dist = Math.min(Math.sqrt(dx*dx + dy*dy), 40);
            const ang = Math.atan2(dy, dx);
            jKnob.style.transform = `translate(${Math.cos(ang)*dist}px, ${Math.sin(ang)*dist}px)`;
            moveState.x = (Math.cos(ang)*dist)/40; moveState.y = (Math.sin(ang)*dist)/40;
        }
        jContainer.addEventListener('touchstart', (e) => { jActive = true; handleJoystick(e); });
        window.addEventListener('touchmove', (e) => { if(jActive) { e.preventDefault(); handleJoystick(e); } }, { passive: false });
        window.addEventListener('touchend', () => { jActive = false; jKnob.style.transform = 'translate(0,0)'; moveState = {x:0, y:0}; });

        // アクション
        const ray = new THREE.Raycaster();
        function performAction(isBuild) {
            ray.setFromCamera(new THREE.Vector2(), camera); ray.far = 6;
            const hits = ray.intersectObjects(Array.from(worldData.values()));
            if (hits.length > 0) {
                const h = hits[0], p = h.point, n = h.face.normal;
                const bx = Math.floor(p.x - n.x*0.01), by = Math.floor(p.y - n.y*0.01), bz = Math.floor(p.z - n.z*0.01);
                if (isBuild) addBlock(bx + Math.round(n.x), by + Math.round(n.y), bz + Math.round(n.z), matIdx);
                else { const key = `${bx},${by},${bz}`; const m = worldData.get(key); if(m){scene.remove(m); worldData.delete(key);} }
            }
        }
        document.getElementById('btn-build').addEventListener('touchstart', (e) => { e.preventDefault(); performAction(true); });
        document.getElementById('btn-break').addEventListener('touchstart', (e) => { e.preventDefault(); performAction(false); });
        document.getElementById('btn-jump').addEventListener('touchstart', (e) => {
            e.preventDefault(); if(player.fly) player.vel.y = 8; else if(player.onGround) { player.vel.y = 8.5; player.onGround = false; }
        });
        document.getElementById('btn-fly-down').addEventListener('touchstart', (e) => { e.preventDefault(); if(player.fly) player.vel.y = -8; });

        document.getElementById('mode-physics-btn').onclick = function() {
            player.fly = !player.fly; this.innerText = player.fly ? "クリエイティブ" : "サバイバル";
            document.getElementById('btn-fly-down').style.display = player.fly ? 'flex' : 'none';
        };
        document.getElementById('block-type-btn').onclick = function() {
            matIdx = (matIdx+1)%3; this.innerText = ["草", "土", "石"][matIdx] + "ブロック";
        };

        let yaw=0, pitch=0, lastX, lastY;
        window.addEventListener('touchstart', (e) => {
            if(e.target.closest('#joystick-container') || e.target.closest('.act-btn') || e.target.closest('.toggle-btn')) return;
            lastX = e.touches[0].clientX; lastY = e.touches[0].clientY;
        });
        window.addEventListener('touchmove', (e) => {
            if(jActive || e.touches.length > 1 || e.target.closest('.act-btn')) return;
            const dx = e.touches[0].clientX - lastX, dy = e.touches[0].clientY - lastY;
            yaw -= dx*0.005; pitch = Math.max(-1.5, Math.min(1.5, pitch - dy*0.005));
            camera.rotation.set(pitch, yaw, 0, 'YXZ');
            lastX = e.touches[0].clientX; lastY = e.touches[0].clientY;
        });

        const clock = new THREE.Clock();
        // --- loop関数内の物理更新部分を以下に差し替えてみてください ---

function loop() {
    requestAnimationFrame(loop);
    // デルタタイムを安定させる（最大0.05秒に制限）
    const dt = Math.min(clock.getDelta(), 0.05);
    
    const fw = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion); fw.y = 0; fw.normalize();
    const rt = new THREE.Vector3(1,0,0).applyQuaternion(camera.quaternion); rt.y = 0; rt.normalize();
    
    if (player.fly) {
        camera.position.addScaledVector(fw, -moveState.y * 10 * dt);
        camera.position.addScaledVector(rt, moveState.x * 10 * dt);
        camera.position.y += player.vel.y * dt;
        player.vel.y *= 0.85; // 減衰
    } else {
        // 1. 水平移動 (X, Z)
        const moveX = (fw.x * -moveState.y + rt.x * moveState.x) * player.speed * dt;
        const moveZ = (fw.z * -moveState.y + rt.z * moveState.x) * player.speed * dt;

        camera.position.x += moveX;
        if (isColliding(camera.position.x, camera.position.y, camera.position.z)) {
            camera.position.x -= moveX;
        }

        camera.position.z += moveZ;
        if (isColliding(camera.position.x, camera.position.y, camera.position.z)) {
            camera.position.z -= moveZ;
        }

        // 2. 垂直移動 (Y)
        // 接地判定用の足元チェック (現在の位置から少し下)
        const checkDist = 0.1; 
        const footPos = camera.position.y - player.eyeHeight;
        const isCurrentlyOverBlock = worldData.has(
            `${Math.floor(camera.position.x)},${Math.floor(footPos - 0.01)},${Math.floor(camera.position.z)}`
        );

        if (isCurrentlyOverBlock && player.vel.y <= 0) {
            // 地面にいる場合：重力を無視し、位置を固定
            player.onGround = true;
            player.vel.y = 0;
            // 地面の高さへスナップ（+0.001の余裕を持たせてバウンドを抑止）
            const targetY = Math.floor(footPos) + 1.0 + player.eyeHeight + 0.001;
            // 差が小さい場合のみ補正（急激なワープを防ぐ）
            if (Math.abs(camera.position.y - targetY) < 0.2) {
                camera.position.y = targetY;
            }
        } else {
            // 空中にいる場合：重力を適用
            player.onGround = false;
            player.vel.y -= player.gravity * dt;
            const moveY = player.vel.y * dt;
            
            camera.position.y += moveY;
            
            // 下方向の衝突
            if (player.vel.y < 0 && isColliding(camera.position.x, camera.position.y, camera.position.z)) {
                player.onGround = true;
                player.vel.y = 0;
                camera.position.y = Math.floor(camera.position.y - player.eyeHeight) + 1.0 + player.eyeHeight + 0.001;
            }
            // 上方向（頭上）の衝突
            if (player.vel.y > 0 && isColliding(camera.position.x, camera.position.y + 0.2, camera.position.z)) {
                player.vel.y = 0;
            }
        }
        
        // 落下しすぎた場合の復帰
        if (camera.position.y < -30) camera.position.set(0, 10, 0);
    }
    renderer.render(scene, camera);
}
        loop();
    };
    </script>
</body>
</html>
