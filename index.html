<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Web Minecraft - Physics Fixed</title>
    <style>
        body { margin: 0; overflow: hidden; touch-action: none; background-color: #87CEEB; font-family: sans-serif; user-select: none; }
        canvas { display: block; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        #joystick-container { position: absolute; bottom: 40px; left: 40px; width: 120px; height: 120px; background: rgba(255, 255, 255, 0.2); border-radius: 50%; pointer-events: auto; border: 2px solid rgba(255, 255, 255, 0.5); }
        #joystick-knob { position: absolute; top: 35px; left: 35px; width: 50px; height: 50px; background: rgba(255, 255, 255, 0.8); border-radius: 50%; pointer-events: none; }
        #action-grid { position: absolute; bottom: 40px; right: 40px; display: grid; grid-template-areas: "up up" "left right" "down down"; gap: 15px; pointer-events: auto; }
        .act-btn { width: 75px; height: 75px; border-radius: 50%; background: rgba(0, 0, 0, 0.4); color: white; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 2px solid #fff; pointer-events: auto; }
        .act-btn:active { background: rgba(255, 255, 255, 0.6); transform: scale(0.9); }
        #btn-build { background: rgba(0, 150, 0, 0.6); grid-area: left; }
        #btn-break { background: rgba(150, 0, 0, 0.6); grid-area: right; }
        #btn-jump { background: rgba(200, 150, 0, 0.6); grid-area: up; }
        #btn-fly-down { background: rgba(50, 50, 50, 0.6); grid-area: down; }
        #top-bar { position: absolute; top: 10px; width: 100%; display: flex; justify-content: center; gap: 10px; pointer-events: auto; }
        .toggle-btn { padding: 10px 15px; background: rgba(0,0,0,0.6); color: white; border-radius: 20px; border: none; }
        #crosshair { position: absolute; top: 50%; left: 50%; width: 12px; height: 12px; border: 2px solid #fff; border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none; }
    </style>
</head>
<body>
    <div id="crosshair"></div>
    <div id="ui-layer">
        <div id="top-bar">
            <button class="toggle-btn" id="mode-physics-btn">サバイバル</button>
            <button class="toggle-btn" id="block-type-btn">土ブロック</button>
        </div>
        <div id="joystick-container"><div id="joystick-knob"></div></div>
        <div id="action-grid">
            <div class="act-btn" id="btn-jump">JUMP</div>
            <div class="act-btn" id="btn-build">おく</div>
            <div class="act-btn" id="btn-break">こわす</div>
            <div class="act-btn" id="btn-fly-down" style="display:none;">下降</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
    window.onload = function() {
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 15, 60);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 0.8));
        camera.position.set(0, 10, 0);

        const worldData = new Map();
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const materials = [
            new THREE.MeshLambertMaterial({ color: 0x4CAF50 }),
            new THREE.MeshLambertMaterial({ color: 0x795548 }),
            new THREE.MeshLambertMaterial({ color: 0x808080 })
        ];

        function addBlock(x, y, z, mIdx) {
            const key = `${x},${y},${z}`;
            if (worldData.has(key)) return;
            const mesh = new THREE.Mesh(geometry, materials[mIdx % 3]);
            mesh.position.set(x + 0.5, y + 0.5, z + 0.5);
            scene.add(mesh);
            worldData.set(key, mesh);
        }

        for (let x = -20; x < 20; x++) {
            for (let z = -20; z < 20; z++) {
                addBlock(x, -1, z, (Math.abs(x+z)%2));
            }
        }

        const player = { 
            radius: 0.3, 
            eyeHeight: 1.6, 
            vel: new THREE.Vector3(), 
            onGround: false, 
            fly: false, 
            speed: 5.5,
            gravity: 24.0
        };
        let moveState = { x: 0, y: 0 };
        let matIdx = 0;

        // 判定用：指定座標にブロックがあるか
        function isBlockAt(x, y, z) {
            return worldData.has(`${Math.floor(x)},${Math.floor(y)},${Math.floor(z)}`);
        }

        // 全方向当たり判定
        function checkCollision(pos) {
            const r = player.radius;
            // 足元(少し上からチェック)、腰、頭の3層で判定
            const levels = [pos.y - player.eyeHeight + 0.2, pos.y - 0.5, pos.y + 0.2];
            for (let ly of levels) {
                if (isBlockAt(pos.x - r, ly, pos.z - r)) return true;
                if (isBlockAt(pos.x + r, ly, pos.z - r)) return true;
                if (isBlockAt(pos.x - r, ly, pos.z + r)) return true;
                if (isBlockAt(pos.x + r, ly, pos.z + r)) return true;
                if (isBlockAt(pos.x, ly, pos.z)) return true;
            }
            return false;
        }

        // ジョイスティック
        const jContainer = document.getElementById('joystick-container');
        const jKnob = document.getElementById('joystick-knob');
        let jActive = false;
        function handleJoystick(e) {
            if (!jActive) return;
            const touch = e.touches ? e.touches[0] : e;
            const rect = jContainer.getBoundingClientRect();
            const dx = touch.clientX - (rect.left + rect.width / 2);
            const dy = touch.clientY - (rect.top + rect.height / 2);
            const dist = Math.min(Math.sqrt(dx*dx + dy*dy), 40);
            const angle = Math.atan2(dy, dx);
            jKnob.style.transform = `translate(${Math.cos(angle)*dist}px, ${Math.sin(angle)*dist}px)`;
            moveState.x = (Math.cos(angle)*dist) / 40; moveState.y = (Math.sin(angle)*dist) / 40;
        }
        jContainer.addEventListener('touchstart', (e) => { jActive = true; handleJoystick(e); });
        window.addEventListener('touchmove', (e) => { if(jActive) { e.preventDefault(); handleJoystick(e); } }, { passive: false });
        window.addEventListener('touchend', () => { jActive = false; jKnob.style.transform = `translate(0,0)`; moveState = { x: 0, y: 0 }; });

        // アクション
        const ray = new THREE.Raycaster();
        function performAction(isBuild) {
            ray.setFromCamera(new THREE.Vector2(), camera); ray.far = 6;
            const hits = ray.intersectObjects(Array.from(worldData.values()));
            if (hits.length > 0) {
                const h = hits[0], p = h.point, n = h.face.normal;
                const bx = Math.floor(p.x - n.x*0.1), by = Math.floor(p.y - n.y*0.1), bz = Math.floor(p.z - n.z*0.1);
                if (isBuild) addBlock(bx + Math.round(n.x), by + Math.round(n.y), bz + Math.round(n.z), matIdx);
                else { const key = `${bx},${by},${bz}`; scene.remove(worldData.get(key)); worldData.delete(key); }
            }
        }
        document.getElementById('btn-build').addEventListener('touchstart', (e) => { e.preventDefault(); performAction(true); });
        document.getElementById('btn-break').addEventListener('touchstart', (e) => { e.preventDefault(); performAction(false); });
        document.getElementById('btn-jump').addEventListener('touchstart', (e) => {
            e.preventDefault(); if (player.fly) player.vel.y = 8; else if (player.onGround) { player.vel.y = 9; player.onGround = false; }
        });
        document.getElementById('btn-fly-down').addEventListener('touchstart', (e) => { e.preventDefault(); if(player.fly) player.vel.y = -8; });

        document.getElementById('mode-physics-btn').onclick = function() {
            player.fly = !player.fly;
            this.innerText = player.fly ? "クリエイティブ" : "サバイバル";
            document.getElementById('btn-fly-down').style.display = player.fly ? 'flex' : 'none';
            document.getElementById('btn-jump').innerText = player.fly ? '上昇' : 'JUMP';
        };
        document.getElementById('block-type-btn').onclick = function() {
            matIdx = (matIdx + 1) % 3;
            this.innerText = ["草ブロック", "土ブロック", "石ブロック"][matIdx];
        };

        let yaw = 0, pitch = 0, lastX, lastY;
        window.addEventListener('touchstart', (e) => {
            if (e.target.closest('#joystick-container') || e.target.closest('.act-btn') || e.target.closest('.toggle-btn')) return;
            lastX = e.touches[0].clientX; lastY = e.touches[0].clientY;
        });
        window.addEventListener('touchmove', (e) => {
            if (jActive || e.touches.length > 1 || e.target.closest('.act-btn')) return;
            const dx = e.touches[0].clientX - lastX; const dy = e.touches[0].clientY - lastY;
            yaw -= dx * 0.005; pitch -= dy * 0.005;
            pitch = Math.max(-1.5, Math.min(1.5, pitch));
            camera.rotation.set(pitch, yaw, 0, 'YXZ');
            lastX = e.touches[0].clientX; lastY = e.touches[0].clientY;
        });

        const clock = new THREE.Clock();
        function loop() {
            requestAnimationFrame(loop);
            const dt = Math.min(clock.getDelta(), 0.1);
            const fw = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion); fw.y = 0; fw.normalize();
            const rt = new THREE.Vector3(1,0,0).applyQuaternion(camera.quaternion); rt.y = 0; rt.normalize();
            
            if (player.fly) {
                camera.position.addScaledVector(fw, -moveState.y * 10 * dt);
                camera.position.addScaledVector(rt, moveState.x * 10 * dt);
                camera.position.y += player.vel.y * dt;
                player.vel.y *= 0.85;
            } else {
                // 水平移動
                let nextX = camera.position.x + (fw.x * -moveState.y + rt.x * moveState.x) * player.speed * dt;
                let nextZ = camera.position.z + (fw.z * -moveState.y + rt.z * moveState.x) * player.speed * dt;
                
                if (!checkCollision({x: nextX, y: camera.position.y, z: camera.position.z})) camera.position.x = nextX;
                if (!checkCollision({x: camera.position.x, y: camera.position.y, z: nextZ})) camera.position.z = nextZ;

                // 垂直移動（重力）
                player.vel.y -= player.gravity * dt;
                let nextY = camera.position.y + player.vel.y * dt;

                // 接地・衝突判定のコア
                if (player.vel.y < 0) { // 落下中
                    // 足元よりわずかに下をチェック
                    const footY = nextY - player.eyeHeight;
                    if (isBlockAt(camera.position.x, footY, camera.position.z)) {
                        player.onGround = true;
                        player.vel.y = 0;
                        // 座標を地面の高さに完全に固定（これがバウンドを防ぐ）
                        camera.position.y = Math.floor(footY) + 1.0 + player.eyeHeight;
                    } else {
                        camera.position.y = nextY;
                        player.onGround = false;
                    }
                } else if (player.vel.y > 0) { // 上昇中（ジャンプ）
                    if (isBlockAt(camera.position.x, nextY + 0.3, camera.position.z)) {
                        player.vel.y = 0; // 頭をぶつけた
                    } else {
                        camera.position.y = nextY;
                        player.onGround = false;
                    }
                }
            }
            renderer.render(scene, camera);
        }
        loop();
    };
    </script>
</body>
</html>
