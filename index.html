<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Web Minecraft Mobile - Final Stable</title>
    <style>
        body { margin: 0; overflow: hidden; touch-action: none; background-color: #87CEEB; font-family: sans-serif; user-select: none; }
        canvas { display: block; }
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }

        .btn {
            background: rgba(255, 255, 255, 0.5);
            border: 2px solid #fff; border-radius: 10px;
            pointer-events: auto; display: flex; align-items: center; justify-content: center;
            font-weight: bold; font-size: 20px;
        }

        #d-pad { position: absolute; bottom: 30px; left: 30px; width: 150px; height: 150px; }
        #btn-fwd { position: absolute; top: 0; left: 50px; width: 50px; height: 50px; }
        #btn-back { position: absolute; bottom: 0; left: 50px; width: 50px; height: 50px; }
        #btn-left { position: absolute; top: 50px; left: 0; width: 50px; height: 50px; }
        #btn-right { position: absolute; top: 50px; right: 0; width: 50px; height: 50px; }

        #actions { position: absolute; bottom: 30px; right: 30px; display: flex; flex-direction: column; gap: 10px; }
        .round-btn { width: 70px; height: 70px; border-radius: 50%; }
        
        #top-bar { position: absolute; top: 10px; width: 100%; display: flex; justify-content: center; gap: 10px; pointer-events: auto; }
        .toggle-btn { padding: 10px 15px; background: rgba(0,0,0,0.6); color: white; border: none; border-radius: 20px; font-size: 14px; }

        #crosshair { position: absolute; top: 50%; left: 50%; width: 10px; height: 10px; border: 2px solid #fff; border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none; }
    </style>
</head>
<body>

    <div id="crosshair"></div>
    <div id="ui-layer">
        <div id="top-bar">
            <button class="toggle-btn" id="mode-physics-btn">サバイバル</button>
            <button class="toggle-btn" id="mode-block-btn">置く (緑)</button>
        </div>
        <div id="d-pad">
            <div class="btn" id="btn-fwd">▲</div>
            <div class="btn" id="btn-left">◀</div>
            <div class="btn" id="btn-right">▶</div>
            <div class="btn" id="btn-back">▼</div>
        </div>
        <div id="actions">
            <div class="btn round-btn" id="btn-fly-up" style="display:none;">上昇</div>
            <div class="btn round-btn" id="btn-fly-down" style="display:none;">下降</div>
            <div class="btn round-btn" id="btn-jump">JUMP</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
    window.onload = function() {
        // --- 基本設定 ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 10, 50);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 0.8));
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.4);
        dirLight.position.set(5, 10, 5);
        scene.add(dirLight);

        // --- ワールド生成 ---
        const worldData = new Map();
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const materials = [
            new THREE.MeshLambertMaterial({ color: 0x4CAF50 }), // 緑
            new THREE.MeshLambertMaterial({ color: 0x795548 }), // 茶
            new THREE.MeshLambertMaterial({ color: 0x808080 })  // 灰
        ];

        function addBlock(x, y, z, mIdx) {
            const key = `${x},${y},${z}`;
            if (worldData.has(key)) return;
            const mesh = new THREE.Mesh(geometry, materials[mIdx % 3]);
            mesh.position.set(x + 0.5, y + 0.5, z + 0.5);
            scene.add(mesh);
            worldData.set(key, mesh);
        }

        // 初期地面作成
        for (let x = -10; x < 10; x++) {
            for (let z = -10; z < 10; z++) {
                addBlock(x, -1, z, (Math.abs(x+z)%2));
            }
        }
        camera.position.set(0, 3, 5);

        // --- 物理と入力 ---
        const player = { vel: new THREE.Vector3(), onGround: false, fly: false, speed: 6, jump: 10, gravity: 25 };
        const input = { fwd: false, back: false, left: false, right: false, jump: false, up: false, down: false };

        const bind = (id, key) => {
            const el = document.getElementById(id);
            if (!el) return;
            const set = (v) => (e) => { e.preventDefault(); input[key] = v; };
            el.addEventListener('touchstart', set(true));
            el.addEventListener('touchend', set(false));
            el.addEventListener('mousedown', set(true));
            el.addEventListener('mouseup', set(false));
        };
        bind('btn-fwd', 'fwd'); bind('btn-back', 'back'); bind('btn-left', 'left'); bind('btn-right', 'right');
        bind('btn-jump', 'jump'); bind('btn-fly-up', 'up'); bind('btn-fly-down', 'down');

        // --- モード切替 ---
        let buildMode = true, colorIdx = 0;
        document.getElementById('mode-physics-btn').onclick = function() {
            player.fly = !player.fly;
            this.innerText = player.fly ? "クリエイティブ" : "サバイバル";
            document.getElementById('btn-jump').style.display = player.fly ? 'none' : 'flex';
            document.getElementById('btn-fly-up').style.display = player.fly ? 'flex' : 'none';
            document.getElementById('btn-fly-down').style.display = player.fly ? 'flex' : 'none';
        };
        document.getElementById('mode-block-btn').onclick = function() {
            buildMode = !buildMode;
            if(buildMode) {
                colorIdx = (colorIdx + 1) % 3;
                const names = ["緑", "茶", "灰"];
                this.innerText = "置く (" + names[colorIdx] + ")";
            } else {
                this.innerText = "壊す";
            }
        };

        // --- 視点移動 ---
        let yaw = 0, pitch = 0, dragging = false, lastX, lastY;
        document.addEventListener('touchstart', (e) => {
            if (e.target.closest('.btn') || e.target.closest('.toggle-btn')) return;
            dragging = true;
            lastX = e.touches[0].clientX; lastY = e.touches[0].clientY;
            if(e.touches.length === 1) handleAction();
        });
        document.addEventListener('touchmove', (e) => {
            if (!dragging) return;
            const dx = e.touches[0].clientX - lastX;
            const dy = e.touches[0].clientY - lastY;
            yaw -= dx * 0.005; pitch -= dy * 0.005;
            pitch = Math.max(-1.5, Math.min(1.5, pitch));
            camera.rotation.set(pitch, yaw, 0, 'YXZ');
            lastX = e.touches[0].clientX; lastY = e.touches[0].clientY;
        });
        document.addEventListener('touchend', () => dragging = false);

        // --- 物理判定 ---
        function check(pos) {
            const x = Math.floor(pos.x), y = Math.floor(pos.y - 1.5), z = Math.floor(pos.z);
            return worldData.has(`${x},${y},${z}`) || worldData.has(`${x},${Math.floor(pos.y-0.5)},${z}`);
        }

        function handleAction() {
            const ray = new THREE.Raycaster();
            ray.setFromCamera(new THREE.Vector2(), camera);
            ray.far = 6;
            const hits = ray.intersectObjects(Array.from(worldData.values()));
            if (hits.length > 0) {
                const h = hits[0], p = h.point, n = h.face.normal;
                const bx = Math.floor(p.x - n.x*0.1), by = Math.floor(p.y - n.y*0.1), bz = Math.floor(p.z - n.z*0.1);
                if (buildMode) {
                    addBlock(bx + Math.round(n.x), by + Math.round(n.y), bz + Math.round(n.z), colorIdx);
                } else {
                    const key = `${bx},${by},${bz}`;
                    if(worldData.has(key)) {
                        scene.remove(worldData.get(key));
                        worldData.delete(key);
                    }
                }
            }
        }

        const clock = new THREE.Clock();
        function loop() {
            requestAnimationFrame(loop);
            const dt = Math.min(clock.getDelta(), 0.1);
            
            const fw = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion); fw.y = 0; fw.normalize();
            const rt = new THREE.Vector3(1,0,0).applyQuaternion(camera.quaternion); rt.y = 0; rt.normalize();
            
            const move = new THREE.Vector3();
            if(input.fwd) move.add(fw); if(input.back) move.sub(fw);
            if(input.right) move.add(rt); if(input.left) move.sub(rt);
            
            if(move.length() > 0) {
                move.normalize();
                camera.position.x += move.x * player.speed * dt;
                camera.position.z += move.z * player.speed * dt;
            }

            if (player.fly) {
                if(input.up) camera.position.y += player.speed * dt;
                if(input.down) camera.position.y -= player.speed * dt;
            } else {
                player.vel.y -= player.gravity * dt;
                if(input.jump && player.onGround) { player.vel.y = player.jump; player.onGround = false; }
                camera.position.y += player.vel.y * dt;
                if(check(camera.position)) {
                    if(player.vel.y < 0) {
                        player.onGround = true;
                        camera.position.y = Math.floor(camera.position.y - 1.5) + 2.5;
                    }
                    player.vel.y = 0;
                } else {
                    player.onGround = false;
                }
            }
            renderer.render(scene, camera);
        }
        loop();
    };
    </script>
</body>
